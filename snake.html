<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>贪吃蛇 | 极速响应版 V3</title>
    <style>
        /* --- 全局设置 --- */
        * { margin: 0; padding: 0; box-sizing: border-box; 
            user-select: none; -webkit-user-select: none; 
            -webkit-touch-callout: none; touch-action: none; /* 禁止所有默认手势 */
        }
        body { 
            display: flex; align-items: center; justify-content: center; 
            background-color: #f0f2f5; font-family: "Microsoft YaHei", sans-serif; 
            overflow: hidden; height: 100vh; padding: 10px; gap: 20px; 
        }

        /* --- 游戏主界面 --- */
        .game-area { display: flex; flex-direction: column; align-items: center; position: relative; }
        
        h1 { 
            font-size: clamp(1.2rem, 4vw, 1.5rem); color: #34495e; margin-bottom: 5px; font-weight: 700;
        }

        .score-board {
            background: #fff; padding: 5px 20px; border-radius: 50px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05); margin-bottom: 10px;
            font-weight: bold; color: #555; font-size: 1.1rem;
        }

        #gameCanvas { 
            background-color: #fff; border-radius: 8px; 
            box-shadow: 0 5px 20px rgba(0,0,0,0.1); 
            width: clamp(300px, 90vw, 380px); 
            height: auto; aspect-ratio: 1/1; 
            image-rendering: pixelated; /* 保持像素清晰 */
        }

        /* --- 虚拟手柄区域 --- */
        .controls-container {
            position: relative; margin-top: 10px;
            /* 增加额外的触摸判定区，防止误触背景 */
            padding: 10px; 
        }

        .cross-key { 
            display: grid; 
            grid-template-areas: " . up . " " left mid right " " . down . "; 
            gap: 10px; /* 按钮之间拉开一点距离，防止误触 */
        }

        .dir-btn { 
            width: clamp(60px, 16vw, 80px); 
            height: clamp(60px, 16vw, 80px); 
            border: none; border-radius: 12px; 
            background: #dfe6e9; 
            box-shadow: 0 4px 0 #b2bec3; /* 模拟物理按钮的厚度 */
            color: #636e72; font-size: 1.5rem; 
            display: flex; align-items: center; justify-content: center;
            transition: all 0.05s;
            position: relative;
        }

        /* 扩大触摸热区：伪元素覆盖在按钮周围 */
        .dir-btn::after {
            content: ''; position: absolute;
            top: -10px; bottom: -10px; left: -10px; right: -10px;
            z-index: 1;
        }

        /* 按下状态：按钮下沉，阴影消失，颜色变深 */
        .dir-btn:active, .dir-btn.active-state { 
            transform: translateY(4px); 
            box-shadow: 0 0 0 #b2bec3; 
            background: #74b9ff; color: white;
        }

        #upBtn { grid-area: up; } 
        #leftBtn { grid-area: left; } 
        #rightBtn { grid-area: right; } 
        #downBtn { grid-area: down; }
        .mid-key { grid-area: mid; } /* 占位 */

        /* --- 弹窗 --- */
        .overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.6);
            display: flex; flex-direction: column; 
            align-items: center; justify-content: center;
            border-radius: 8px; z-index: 50;
            color: white; text-align: center;
            backdrop-filter: blur(2px);
        }
        .start-msg { font-size: 1.2rem; margin-bottom: 20px; animation: pulse 1.5s infinite; }
        .game-over-msg { display: none; }
        
        .action-btn {
            padding: 10px 30px; border-radius: 25px; border: none;
            background: #00cec9; color: white; font-size: 1rem; font-weight: bold;
            box-shadow: 0 4px 0 #00b894; cursor: pointer;
        }
        .action-btn:active { transform: translateY(4px); box-shadow: none; }

        @keyframes pulse { 0% { opacity: 0.8; } 50% { opacity: 1; transform: scale(1.05); } 100% { opacity: 0.8; } }

        /* 竖屏适配 */
        @media (max-width: 650px) {
            body { flex-direction: column; gap: 10px; }
            .controls-container { transform: scale(1); } /* 保持大按钮 */
        }
    </style>
</head>
<body>

    <div class="game-area">
        <h1>贪吃蛇 V3</h1>
        <div class="score-board">得分: <span id="score">0</span></div>
        <canvas id="gameCanvas" width="400" height="400"></canvas>
        
        <div class="overlay" id="overlay">
            <div id="startScreen">
                <div class="start-msg">按任意方向键开始</div>
            </div>
            <div id="gameOverScreen" class="game-over-msg">
                <h2>游戏结束</h2>
                <p>最终得分: <span id="finalScore">0</span></p>
                <br>
                <button class="action-btn" id="retryBtn">再玩一次</button>
            </div>
        </div>
    </div>

    <div class="controls-container">
        <div class="cross-key">
            <button class="dir-btn" id="upBtn" data-dir="up">▲</button>
            <button class="dir-btn" id="leftBtn" data-dir="left">◀</button>
            <div class="mid-key"></div>
            <button class="dir-btn" id="rightBtn" data-dir="right">▶</button>
            <button class="dir-btn" id="downBtn" data-dir="down">▼</button>
        </div>
    </div>

    <script>
        // --- 核心配置 ---
        const CONFIG = {
            speed: 130, // 毫秒/帧 (越小越快)
            grid: 20,   // 格子大小
            vibrate: true // 开启震动
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const overlay = document.getElementById('overlay');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreEl = document.getElementById('finalScore');
        const retryBtn = document.getElementById('retryBtn');

        // 计算网格数量
        const tileCount = canvas.width / CONFIG.grid;

        // 游戏变量
        let snake = [];
        let food = {};
        let dx = 0; // X轴速度
        let dy = 0; // Y轴速度
        let score = 0;
        let gameLoopId = null;
        let isGameRunning = false;
        let inputQueue = []; // 输入缓冲队列

        // 初始化游戏（只重置数据，不自动开始跑）
        function resetGameData() {
            // 蛇头放在中间
            const center = Math.floor(tileCount / 2);
            snake = [{x: center, y: center}]; 
            // 初始没有速度，等待输入
            dx = 0;
            dy = 0;
            score = 0;
            scoreEl.innerText = score;
            inputQueue = [];
            spawnFood();
            draw(); // 绘制初始画面
        }

        // --- 核心：输入处理 ---
        function handleInput(dir) {
            // 1. 如果游戏结束了，点击任何键都不处理（等待点击重试按钮）
            if (gameOverScreen.style.display === 'block') return;

            // 2. 如果游戏还没开始（显示开始画面），第一下按键负责启动
            if (!isGameRunning) {
                startGame(dir);
                return;
            }

            // 3. 震动反馈 (提升手感)
            if (CONFIG.vibrate && navigator.vibrate) {
                navigator.vibrate(10); // 震动10毫秒，轻微反馈
            }

            // 4. 将指令推入队列
            // 获取"逻辑上的队尾"，如果队列为空，就是当前真实速度方向
            const lastMove = inputQueue.length > 0 ? inputQueue[inputQueue.length - 1] : getCurrentDirection();
            
            // 检查：禁止直接掉头
            if (dir === 'up' && lastMove === 'down') return;
            if (dir === 'down' && lastMove === 'up') return;
            if (dir === 'left' && lastMove === 'right') return;
            if (dir === 'right' && lastMove === 'left') return;
            
            // 检查：不要重复推入相同方向 (按太快可能导致重复)
            if (dir === lastMove) return;

            // 限制队列长度：防止按太快蛇像脚本一样自动跑很久
            if (inputQueue.length < 3) {
                inputQueue.push(dir);
            }
        }

        // 获取当前蛇的移动方向字符串
        function getCurrentDirection() {
            if (dx === 0 && dy === -1) return 'up';
            if (dx === 0 && dy === 1) return 'down';
            if (dx === -1 && dy === 0) return 'left';
            if (dx === 1 && dy === 0) return 'right';
            return null; // 还没开始动
        }

        // --- 游戏启动逻辑 ---
        function startGame(firstDir) {
            isGameRunning = true;
            overlay.style.display = 'none'; // 隐藏遮罩
            startScreen.style.display = 'none';
            
            // 立即设置第一帧的方向
            inputQueue = [firstDir]; 
            
            // 开始循环
            if (gameLoopId) clearInterval(gameLoopId);
            gameLoopId = setInterval(gameStep, CONFIG.speed);
        }

        // --- 游戏主循环 ---
        function gameStep() {
            // 1. 消耗输入队列
            if (inputQueue.length > 0) {
                const nextDir = inputQueue.shift();
                switch(nextDir) {
                    case 'up': dx = 0; dy = -1; break;
                    case 'down': dx = 0; dy = 1; break;
                    case 'left': dx = -1; dy = 0; break;
                    case 'right': dx = 1; dy = 0; break;
                }
            }

            // 2. 如果还没动（比如刚reset），不更新逻辑
            if (dx === 0 && dy === 0) return;

            // 3. 计算新蛇头
            const head = { x: snake[0].x + dx, y: snake[0].y + dy };

            // 4. 死亡检测
            // 撞墙
            if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                return gameOver();
            }
            // 撞自己 (从索引1开始，因为0是头)
            for (let i = 0; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    return gameOver();
                }
            }

            // 5. 移动蛇
            snake.unshift(head); // 加头

            // 6. 吃食物
            if (head.x === food.x && head.y === food.y) {
                score += 10;
                scoreEl.innerText = score;
                spawnFood();
                // 吃到东西给个稍微长点的震动奖励
                if (CONFIG.vibrate && navigator.vibrate) navigator.vibrate(20);
            } else {
                snake.pop(); // 没吃到，去尾
            }

            draw();
        }

        // --- 绘制 ---
        function draw() {
            // 清空画布
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 画蛇
            snake.forEach((part, index) => {
                // 蛇头深色，身体渐变
                ctx.fillStyle = index === 0 ? '#2d3436' : '#636e72';
                ctx.beginPath();
                ctx.roundRect(
                    part.x * CONFIG.grid + 1, 
                    part.y * CONFIG.grid + 1, 
                    CONFIG.grid - 2, 
                    CONFIG.grid - 2, 
                    4
                );
                ctx.fill();
            });

            // 画食物
            ctx.fillStyle = '#ff7675';
            ctx.beginPath();
            ctx.arc(
                food.x * CONFIG.grid + CONFIG.grid/2, 
                food.y * CONFIG.grid + CONFIG.grid/2, 
                CONFIG.grid/2 - 2, 
                0, Math.PI * 2
            );
            ctx.fill();
        }

        function spawnFood() {
            let valid = false;
            while (!valid) {
                food = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount)
                };
                // 确保食物不生成在蛇身上
                valid = !snake.some(part => part.x === food.x && part.y === food.y);
            }
        }

        function gameOver() {
            isGameRunning = false;
            clearInterval(gameLoopId);
            if (CONFIG.vibrate && navigator.vibrate) navigator.vibrate([50, 50, 50]); // 震动三下
            
            overlay.style.display = 'flex';
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'block';
            finalScoreEl.innerText = score;
        }

        // --- 事件监听 ---
        
        // 键盘
        document.addEventListener('keydown', (e) => {
            const keyMap = {
                'ArrowUp': 'up', 'w': 'up',
                'ArrowDown': 'down', 's': 'down',
                'ArrowLeft': 'left', 'a': 'left',
                'ArrowRight': 'right', 'd': 'right'
            };
            if (keyMap[e.key]) handleInput(keyMap[e.key]);
        });

        // 触摸按钮 (核心优化)
        const btns = document.querySelectorAll('.dir-btn');
        btns.forEach(btn => {
            const dir = btn.dataset.dir;
            
            // 使用 touchstart 替代 click，实现零延迟
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault(); // 阻止浏览器默认行为
                handleInput(dir);
                btn.classList.add('active-state'); // 手动触发视觉反馈
            }, { passive: false });

            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                btn.classList.remove('active-state');
            });

            // 兼容鼠标点击（PC端测试用）
            btn.addEventListener('mousedown', () => {
                handleInput(dir);
                btn.classList.add('active-state');
            });
            btn.addEventListener('mouseup', () => btn.classList.remove('active-state'));
            btn.addEventListener('mouseleave', () => btn.classList.remove('active-state'));
        });

        // 重试按钮
        retryBtn.addEventListener('click', () => {
            resetGameData();
            startScreen.style.display = 'block';
            gameOverScreen.style.display = 'none';
            // 不自动开始，等待玩家按方向键
        });
        retryBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            retryBtn.click();
        });

        // 启动初始化
        resetGameData();

    </script>
</body>
</html>
